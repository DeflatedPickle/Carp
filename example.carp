package Carp

# Comment

#-
    Multi-line
    Comment
-#

class MyClass {
    # Variable access type can be set in blocks
    private {
        my_int: 1337
        my_str: "Hello"
        my_list: ["Hello", "World"]
        my_bool: true

        # Types of variables are only set if not given a value
        my_empty -> Integer
        # Types can also be given for documentation reasons, though
        # my_empty -> Integer: 5
    }

    public {
        my_name: "MyClass"
    }

    # The init method is called when an instance of a class is made (var: MyClass(*parameters)).
    func initialize() {
        # Variables are set with a colon
        one: "Hello"
        two: "World!"
        
        print(one, ", ", two)

        # Testing if a variable is equal to another is done with one "="
        if one = two {
            print("I don't know how that happened.")
        }

        # A try/catch statement will try to run a block of code
        # If there are any, the first error will be caught, and the catch block will be run
        try {
            my_empty: "This causes an error!"
        }
        catch TypeError {
            my_empty: 5
        }
    }

    # Function parameter types are set with "->"
    func hello(name -> String) {
        doc {
            This function welcomes the caller.

            name: The name to say "Hello" to.
        }

        print(f"Hello, {name}")  # Prints a formatted string.
    }

    func add(number_one -> Integer, number_two -> Integer) -> Integer {
        return number_one + number_two
    }

    # Variable over-loading is supported
    func add(*numbers -> List<Integer>) -> Integer {
        sum_: 0

        for num in numbers {
            sum+: num
        }

        return sum
    }
}


class MyNewClass {
    func sub(*numbers -> List<Integer>) -> Integer {
        sum_: 0

        for num in numbers {
            sum-: num
        }

        return sum
    }

    func add_one(number -> Integer) -> Integer {
        return number++
    }
}


# Classes can inherent from multiple other classes
class MultipleInheritance extends MyClass, MyNewClass {
}


# Like in Kotlin, an object is a class that contains an instance of the class
object MyObject {
    # Objects work just like classes, but have an instance of themselves.
}